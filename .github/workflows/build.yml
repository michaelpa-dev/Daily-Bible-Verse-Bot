name: Build and Release

on:
  push:
    branches:
      - canary
    tags:
      - 'v*'
  workflow_dispatch: {}

permissions:
  actions: write
  contents: write

concurrency:
  group: build-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build:
    name: Build + Package + Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # We need tags/history to compute previous_tag and diff for release notes.
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Resolve release metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          prerelease="true"
          if [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            release_tag="${GITHUB_REF#refs/tags/}"
            prerelease="false"
            release_name="Daily Bible Verse Bot ${release_tag}"
          else
            release_tag="canary-${GITHUB_SHA}"
            short_sha="${GITHUB_SHA::7}"
            release_name="Canary ${short_sha}"
          fi

          asset_name="daily-bible-verse-bot-${release_tag}.tar.gz"

          echo "release_tag=${release_tag}" >> "$GITHUB_OUTPUT"
          echo "prerelease=${prerelease}" >> "$GITHUB_OUTPUT"
          echo "release_name=${release_name}" >> "$GITHUB_OUTPUT"
          echo "asset_name=${asset_name}" >> "$GITHUB_OUTPUT"

      - name: Package release artifact
        id: package
        shell: bash
        run: |
          set -euo pipefail

          asset_name="${{ steps.meta.outputs.asset_name }}"

          mkdir -p build
          built_at="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          cat > build/version.json <<EOF
          {
            "tag": "${{ steps.meta.outputs.release_tag }}",
            "sha": "${GITHUB_SHA}",
            "builtAt": "${built_at}",
            "runId": "${GITHUB_RUN_ID}",
            "runNumber": "${GITHUB_RUN_NUMBER}"
          }
          EOF

          # Keep the artifact small and deterministic.
          tar -czf "${asset_name}" \
            build/version.json \
            Dockerfile \
            docker-compose.prod.yml \
            package.json \
            package-lock.json \
            readme.md \
            assets \
            cfg/config-sample.json \
            docs \
            js \
            scripts

          echo "asset_path=${asset_name}" >> "$GITHUB_OUTPUT"

      - name: Build release notes body
        id: notes
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ steps.meta.outputs.release_tag }}
          PRERELEASE: ${{ steps.meta.outputs.prerelease }}
        run: |
          set -euo pipefail

          if [ "${PRERELEASE}" = "true" ]; then
            cat > release_body.md <<EOF
          Canary build: \`${RELEASE_TAG}\`

          This is an automated prerelease build for the \`canary\` branch.
          EOF

            echo "release_body_path=release_body.md" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Stable release: generate notes, then wrap in the repo's release template.
          # "Previous" tag = second newest v* tag (the newest is the one we're building).
          previous_tag="$(git tag --list 'v*' --sort=-v:refname | sed -n '2p' || true)"

          generated_notes="$(gh api -X POST "repos/${GITHUB_REPOSITORY}/releases/generate-notes" \
            -H "Accept: application/vnd.github+json" \
            -f tag_name="${RELEASE_TAG}" \
            ${previous_tag:+-f previous_tag_name="${previous_tag}"} \
            -f target_commitish="${GITHUB_SHA}" \
            --jq .body)"

          # Avoid duplicating the Full Changelog link; we'll add our own at the end to match older releases.
          generated_notes_stripped="$(printf '%s' "${generated_notes}" | sed '/\\*\\*Full Changelog\\*\\*/d')"

          changelog_url="https://github.com/${GITHUB_REPOSITORY}/commits/${RELEASE_TAG}"
          if [ -n "${previous_tag}" ]; then
            changelog_url="https://github.com/${GITHUB_REPOSITORY}/compare/${previous_tag}...${RELEASE_TAG}"
          fi

          deployment_changes="false"
          if [ -n "${previous_tag}" ]; then
            if git diff --name-only "${previous_tag}..${RELEASE_TAG}" | grep -E -q '^(\\.github/workflows/|scripts/deploy/|infra/|docs/deployments/)'; then
              deployment_changes="true"
            fi
          fi

          cat > release_body.md <<EOF
          ## ðŸš€ New Release: Daily Bible Verse Bot ${RELEASE_TAG} ðŸ“–

          We're excited to publish ${RELEASE_TAG}! This release ships new functionality and improvements for the Daily Bible Verse Bot.

          ${generated_notes_stripped}

          EOF

          if [ "${deployment_changes}" = "true" ]; then
            cat >> release_body.md <<EOF

          ## Deployment
          - This release includes deployment or infrastructure changes. Review \`docs/deployments/runbook.md\` before promoting.
          EOF
          fi

          cat >> release_body.md <<'EOF'

          ðŸ”— **Features:**
          - Receive a daily Bible verse delivered to your DM.
          - Request a random Bible verse on demand.
          - Subscribe to daily Bible verses and unsubscribe anytime.
          - Check bot statistics, including user subscriptions and command usage.
          - Post passages in-channel or via DM with robust parsing and pagination.
          - Use a DM page-turner reader with chapter navigation.
          - Run reading plans scheduled inside the bot process (SQLite-backed).
          - Customizable status messages to keep your server engaged.

          ðŸ“ **Usage:**
          1. Clone this repository to your local machine.
          2. Install dependencies using `npm install`.
          3. Configure your bot by copying `cfg/config-sample.json` to `cfg/config.json` and adding your bot token (local only).
          4. Run the bot using `npm start` for local development.
          5. Production deployments use Docker on EC2 via GitHub Releases + AWS SSM (see `docs/deployments/runbook.md`).

          ðŸ“š **Available Commands:**
          - `/subscribe`: Subscribe to daily Bible verses.
          - `/unsubscribe`: Unsubscribe from receiving daily verses.
          - `/stats`: View bot statistics and command usage.
          - `/randomverse`: Get a random Bible verse via DM.
          - `/passage`: Post a passage with robust reference parsing and pagination.
          - `/read`: DM page-turner reader mode.
          - `/plan`: Reading plans.
          - `/support`: Get a link to the GitHub issue tracker for support.

          ðŸ“¢ **Contributions and Feedback:**
          We value your contributions and feedback as we continue to improve the Daily Bible Verse Bot.

          ðŸ”— **Links:**
          - [Repository](https://github.com/michaelpa-dev/Daily-Bible-Verse-Bot)
          - [Invite Bot](https://discord.com/api/oauth2/authorize?client_id=1138224345446105108&permissions=380104993792&scope=applications.commands%20bot)

          EOF

          printf '\n**Full Changelog**: %s\n' "${changelog_url}" >> release_body.md

          echo "previous_tag=${previous_tag}" >> "$GITHUB_OUTPUT"
          echo "release_body_path=release_body.md" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release (upload asset)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.release_tag }}
          name: ${{ steps.meta.outputs.release_name }}
          prerelease: ${{ steps.meta.outputs.prerelease }}
          body_path: ${{ steps.notes.outputs.release_body_path }}
          generate_release_notes: false
          files: ${{ steps.package.outputs.asset_path }}

      - name: Prune old canary releases (keep latest 5)
        if: steps.meta.outputs.prerelease == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          CURRENT_TAG: ${{ steps.meta.outputs.release_tag }}
        run: |
          set -euo pipefail

          echo "Pruning old canary prereleases (tag prefix canary-), keeping newest 5..."

          releases="$(gh api "repos/${GITHUB_REPOSITORY}/releases?per_page=100" --paginate 2>/dev/null || true)"
          if [ -z "${releases}" ]; then
            echo "Warning: unable to list releases (API error or rate limit). Skipping prune."
            exit 0
          fi

          to_delete="$(printf '%s' "${releases}" | jq -r '
            [
              .[]
              | select(.prerelease == true)
              | select(.tag_name | startswith("canary-"))
              | { tag: .tag_name, sortKey: (.published_at // .created_at // .updated_at) }
            ]
            | sort_by(.sortKey)
            | reverse
            | .[5:]
            | .[].tag
          ' 2>/dev/null)" || {
            echo "Warning: jq failed while computing releases to delete. Skipping prune."
            exit 0
          }

          # Safety guard: never delete the release we just created for this workflow run,
          # even if sorting/ordering is unexpected.
          if [ -n "${to_delete}" ] && [ "${to_delete}" != "null" ]; then
            to_delete="$(printf '%s\n' "${to_delete}" | grep -v "^${CURRENT_TAG}$" || true)"
          fi

          if [ -z "${to_delete}" ] || [ "${to_delete}" = "null" ]; then
            echo "No old canary releases to delete."
            exit 0
          fi

          echo "Deleting the following canary releases:"
          echo "${to_delete}"

          while IFS= read -r tag; do
            if [ -z "${tag}" ]; then
              continue
            fi
            echo "Deleting canary release ${tag}..."
            gh release delete "${tag}" --repo "${GITHUB_REPOSITORY}" --yes --cleanup-tag || echo "Warning: failed to delete ${tag} (continuing)"
          done <<< "${to_delete}"

      - name: Dispatch production deploy (release-only)
        if: steps.meta.outputs.prerelease == 'false'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ steps.meta.outputs.release_tag }}
        run: |
          set -euo pipefail

          # Release creation is immediate, but allow for API propagation before triggering a deploy.
          for i in $(seq 1 10); do
            if gh api "repos/${GITHUB_REPOSITORY}/releases/tags/${RELEASE_TAG}" >/dev/null 2>&1; then
              break
            fi
            echo "Waiting for release ${RELEASE_TAG} to be visible (attempt ${i}/10)..."
            sleep 3
          done

          if ! gh api "repos/${GITHUB_REPOSITORY}/releases/tags/${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Release ${RELEASE_TAG} is not visible via API; refusing to dispatch prod deploy." >&2
            exit 1
          fi

          echo "Dispatching production deploy for ${RELEASE_TAG}..."
          gh workflow run deploy-prod.yml --repo "${GITHUB_REPOSITORY}" --ref "master" -f release_tag="${RELEASE_TAG}"
