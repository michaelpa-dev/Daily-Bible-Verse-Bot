name: Deploy Canary (Ephemeral EC2 via SSM)

on:
  push:
    branches:
      - canary
  workflow_dispatch: {}

permissions:
  id-token: write
  contents: read

concurrency:
  # Serialize all canary deployments (shared EC2 target), but avoid collisions with the legacy
  # default-branch workflow which also uses the `deploy-canary` concurrency group.
  group: deploy-canary-v2
  cancel-in-progress: true

jobs:
  deploy:
    name: Deploy Canary
    runs-on: ubuntu-latest
    environment: canary
    env:
      AWS_REGION: us-east-1
      AWS_ROLE_ARN: arn:aws:iam::446363550367:role/DailyBibleVerseBotGitHubActionsRole
      APP_TAG_VALUE: DailyBibleVerseBot
      BOT_TOKEN_PARAMETER_NAME: /daily-bible-verse-bot/canary/BOT_TOKEN
    steps:
      - name: Configure AWS credentials (GitHub OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve canary instance id (by tags)
        id: resolve
        shell: bash
        run: |
          set -euo pipefail

          instance_ids="$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --filters \
              "Name=tag:App,Values=${APP_TAG_VALUE}" \
              "Name=tag:Environment,Values=canary" \
              "Name=instance-state-name,Values=pending,running,stopping,stopped" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text)"

          if [ -z "${instance_ids}" ]; then
            echo "No canary instances found for App=${APP_TAG_VALUE}, Environment=canary"
            exit 1
          fi

          if [ "$(echo "${instance_ids}" | wc -w | tr -d ' ')" != "1" ]; then
            echo "Expected exactly 1 canary instance, found: ${instance_ids}"
            exit 1
          fi

          instance_id="${instance_ids}"
          echo "instance_id=${instance_id}" >> "$GITHUB_OUTPUT"

      - name: Update canary last-push timestamp tag (extends 4h window)
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.resolve.outputs.instance_id }}
        run: |
          set -euo pipefail
          epoch="$(date +%s)"
          iso="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

          aws ec2 create-tags \
            --region "${AWS_REGION}" \
            --resources "${INSTANCE_ID}" \
            --tags \
              "Key=CanaryLastPushEpoch,Value=${epoch}" \
              "Key=CanaryLastPushIso,Value=${iso}" \
              "Key=CanaryAutoStop,Value=enabled"

      - name: Start canary instance if stopped (then wait for health checks)
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.resolve.outputs.instance_id }}
        run: |
          set -euo pipefail

          state="$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --instance-ids "${INSTANCE_ID}" \
            --query "Reservations[0].Instances[0].State.Name" \
            --output text)"

          echo "Canary instance state: ${state}"

          if [ "${state}" = "stopping" ]; then
            aws ec2 wait instance-stopped --region "${AWS_REGION}" --instance-ids "${INSTANCE_ID}"
            state="stopped"
          fi

          if [ "${state}" = "stopped" ]; then
            aws ec2 start-instances --region "${AWS_REGION}" --instance-ids "${INSTANCE_ID}" >/dev/null
          fi

          aws ec2 wait instance-running --region "${AWS_REGION}" --instance-ids "${INSTANCE_ID}"
          aws ec2 wait instance-status-ok --region "${AWS_REGION}" --instance-ids "${INSTANCE_ID}"

      - name: Wait for SSM agent (managed instance online)
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.resolve.outputs.instance_id }}
        run: |
          set -euo pipefail

          echo "Waiting for SSM PingStatus=Online on ${INSTANCE_ID}..."
          for attempt in $(seq 1 40); do
            ping_status="$(aws ssm describe-instance-information \
              --region "${AWS_REGION}" \
              --filters "Key=InstanceIds,Values=${INSTANCE_ID}" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text 2>/dev/null || true)"

            if [ "${ping_status}" = "Online" ]; then
              echo "SSM PingStatus: Online"
              exit 0
            fi

            echo "SSM not online yet (attempt ${attempt}/40). PingStatus=${ping_status:-unknown}. Waiting 10s..."
            sleep 10
          done

          echo "SSM did not report Online for ${INSTANCE_ID} within timeout." >&2
          aws ssm describe-instance-information \
            --region "${AWS_REGION}" \
            --filters "Key=InstanceIds,Values=${INSTANCE_ID}" \
            --output json || true
          exit 1

      - name: Sync BOT_TOKEN to SSM Parameter Store (SecureString)
        shell: bash
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        run: |
          set -euo pipefail
          echo "::add-mask::${BOT_TOKEN}"

          aws ssm put-parameter \
            --region "${AWS_REGION}" \
            --name "${BOT_TOKEN_PARAMETER_NAME}" \
            --type "SecureString" \
            --overwrite \
            --value "${BOT_TOKEN}" >/dev/null

      - name: Resolve GitHub release download URL (private-safe)
        id: artifact
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GH_RELEASE_TOKEN || github.token }}
          GITHUB_REPO: ${{ github.repository }}
          RELEASE_TAG: canary-${{ github.sha }}
        run: |
          set -euo pipefail
          echo "::add-mask::${GITHUB_TOKEN}"

          api="https://api.github.com"
          asset_name="daily-bible-verse-bot-${RELEASE_TAG}.tar.gz"

          # Resolve the release asset ID so we can request a short-lived signed download URL.
          # This avoids 403/404 from unauthenticated downloads for private repos, and keeps tokens off EC2.
          release_url="${api}/repos/${GITHUB_REPO}/releases/tags/${RELEASE_TAG}"
          release_json=""
          for attempt in $(seq 1 40); do
            http_code="$(curl -sS -o release.json -w "%{http_code}" \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${release_url}" || true)"

            if [ "${http_code}" = "200" ]; then
              release_json="$(cat release.json)"
              break
            fi

            if [ "${http_code}" = "404" ]; then
              echo "Release ${RELEASE_TAG} not found yet (attempt ${attempt}/40). Waiting 15s..."
              sleep 15
              continue
            fi

            echo "Failed to fetch release metadata for tag ${RELEASE_TAG} (HTTP ${http_code})." >&2
            cat release.json >&2 || true
            echo "If this repo is private and the default GITHUB_TOKEN cannot read releases, set env secret GH_RELEASE_TOKEN (classic PAT with repo scope) in the 'canary' environment." >&2
            exit 1
          done

          if [ -z "${release_json}" ]; then
            echo "Timed out waiting for the canary release ${RELEASE_TAG} to be created." >&2
            exit 1
          fi

          asset_id="$(printf '%s' "${release_json}" | jq -r --arg name "${asset_name}" '.assets[] | select(.name==$name) | .id' | head -n 1 || true)"

          download_kind="release_asset"
          if [ -z "${asset_id}" ] || [ "${asset_id}" = "null" ]; then
            # Sometimes the release object exists before the asset finishes uploading.
            for attempt in $(seq 1 20); do
              echo "Release asset ${asset_name} not found yet (attempt ${attempt}/20). Waiting 10s..."
              sleep 10

              http_code="$(curl -sS -o release.json -w "%{http_code}" \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                "${release_url}" || true)"
              if [ "${http_code}" != "200" ]; then
                echo "GitHub API returned HTTP ${http_code} while waiting for asset ${asset_name} (attempt ${attempt}/20)." >&2
                continue
              fi

              release_json="$(cat release.json)"
              asset_id="$(printf '%s' "${release_json}" | jq -r --arg name "${asset_name}" '.assets[] | select(.name==$name) | .id' | head -n 1 || true)"
              if [ -n "${asset_id}" ] && [ "${asset_id}" != "null" ]; then
                break
              fi
            done
          fi

          if [ -z "${asset_id}" ] || [ "${asset_id}" = "null" ]; then
            echo "Release asset ${asset_name} not found for ${RELEASE_TAG}; falling back to repo tarball."
            download_kind="source_archive"
            asset_name="source.tar.gz"

            headers="$(curl -sS -D - -o /dev/null \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              "${api}/repos/${GITHUB_REPO}/tarball/${RELEASE_TAG}")"
          else
            headers="$(curl -sS -D - -o /dev/null \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/octet-stream" \
              "${api}/repos/${GITHUB_REPO}/releases/assets/${asset_id}")"
          fi

          download_url="$(printf '%s' "${headers}" | awk -F': ' 'tolower($1)=="location" {print $2}' | tail -n 1 | tr -d '\r')"
          if [ -z "${download_url}" ]; then
            echo "Failed to resolve a signed download URL from GitHub API." >&2
            echo "If using GH_RELEASE_TOKEN, ensure it has access to this repo's releases." >&2
            exit 1
          fi

          echo "::add-mask::${download_url}"
          echo "asset_name=${asset_name}" >> "$GITHUB_OUTPUT"
          echo "download_url=${download_url}" >> "$GITHUB_OUTPUT"
          echo "download_kind=${download_kind}" >> "$GITHUB_OUTPUT"

      - name: Deploy canary via SSM RunCommand (GitHub Release artifact)
        id: ssm
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.resolve.outputs.instance_id }}
          GITHUB_REPO: ${{ github.repository }}
          RELEASE_TAG: canary-${{ github.sha }}
          GIT_SHA: ${{ github.sha }}
          ASSET_NAME: ${{ steps.artifact.outputs.asset_name }}
          ARTIFACT_URL: ${{ steps.artifact.outputs.download_url }}
          DOWNLOAD_KIND: ${{ steps.artifact.outputs.download_kind }}
        run: |
          set -euo pipefail

          deploy_script="$(cat <<SCRIPT
          set -euo pipefail

          DEPLOY_ROOT="/opt/daily-bible-verse-bot"
          ENVIRONMENT="canary"
          GITHUB_REPO="${GITHUB_REPO}"
          RELEASE_TAG="${RELEASE_TAG}"
          GIT_SHA="${GIT_SHA}"
            TOKEN_PARAM="${BOT_TOKEN_PARAMETER_NAME}"

            ASSET_NAME="${ASSET_NAME}"
            ARTIFACT_URL="${ARTIFACT_URL}"
            DOWNLOAD_KIND="${DOWNLOAD_KIND}"

            WORK_DIR="/tmp/dbv-release"
            rm -rf "\${WORK_DIR}"
            mkdir -p "\${WORK_DIR}"
            cd "\${WORK_DIR}"

            echo "Downloading deploy artifact (\${DOWNLOAD_KIND}): \${ASSET_NAME}"
            curl -fL "\${ARTIFACT_URL}" -o "\${ASSET_NAME}"
            tar -xzf "\${ASSET_NAME}" -C "\${WORK_DIR}"

            DEPLOY_SCRIPT_PATH="\${WORK_DIR}/scripts/deploy/ssm-deploy.sh"
            if [ -f "\${DEPLOY_SCRIPT_PATH}" ]; then
              true
            else
              src_dir="$(ls -d "\${WORK_DIR}"/*/ | head -n 1 || true)"
              if [ -z "\${src_dir}" ]; then
                echo "Unable to locate extracted source directory." >&2
                exit 1
              fi
              DEPLOY_SCRIPT_PATH="\${src_dir}scripts/deploy/ssm-deploy.sh"
            fi

            bash "\${DEPLOY_SCRIPT_PATH}" \
              --deploy-root "\${DEPLOY_ROOT}" \
              --environment "\${ENVIRONMENT}" \
              --github-repo "\${GITHUB_REPO}" \
              --release-tag "\${RELEASE_TAG}" \
              --git-sha "\${GIT_SHA}" \
              --token-parameter "\${TOKEN_PARAM}"
          SCRIPT
          )"

          script_b64="$(printf '%s' "${deploy_script}" | base64 -w0)"

          jq -n \
            --arg instanceId "${INSTANCE_ID}" \
            --arg comment "DailyBibleVerseBot canary deploy ${RELEASE_TAG}" \
            --arg scriptB64 "${script_b64}" \
            '{
              DocumentName: "AWS-RunShellScript",
              InstanceIds: [$instanceId],
              Comment: $comment,
              Parameters: {
                commands: [
                  "set -euo pipefail",
                  "printf '\''%s'\'' \"" + $scriptB64 + "\" | base64 -d > /tmp/dbv_deploy.sh",
                  "chmod +x /tmp/dbv_deploy.sh",
                  "/tmp/dbv_deploy.sh"
                ]
              }
            }' > ssm-input.json

          command_id="$(aws ssm send-command \
            --region "${AWS_REGION}" \
            --cli-input-json file://ssm-input.json \
            --query "Command.CommandId" \
            --output text)"

          echo "command_id=${command_id}" >> "$GITHUB_OUTPUT"

      - name: Wait for SSM command + surface output
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.resolve.outputs.instance_id }}
          COMMAND_ID: ${{ steps.ssm.outputs.command_id }}
        run: |
          set -euo pipefail

          status=""
          for attempt in $(seq 1 120); do
            status="$(aws ssm get-command-invocation \
              --region "${AWS_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query "Status" \
              --output text 2>/dev/null || true)"

            if [ -z "${status}" ] || [ "${status}" = "None" ] || [ "${status}" = "null" ]; then
              echo "Waiting for SSM invocation to appear (attempt ${attempt}/120)..."
              sleep 5
              continue
            fi

            echo "SSM status: ${status} (attempt ${attempt}/120)"
            case "${status}" in
              Success|Failed|Cancelled|TimedOut|Undeliverable|Terminated)
                break
                ;;
              *)
                sleep 10
                ;;
            esac
          done

          stdout="$(aws ssm get-command-invocation \
            --region "${AWS_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "StandardOutputContent" \
            --output text)"

          stderr="$(aws ssm get-command-invocation \
            --region "${AWS_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "StandardErrorContent" \
            --output text)"

          echo "SSM status: ${status}"
          echo "${stdout}"
          if [ -n "${stderr}" ] && [ "${stderr}" != "None" ]; then
            echo "${stderr}" >&2
          fi

          if [ "${status}" != "Success" ]; then
            exit 1
          fi

      - name: Cost leak guard (unattached volumes, unassociated EIPs)
        shell: bash
        run: |
          set -euo pipefail

          available_volumes="$(aws ec2 describe-volumes \
            --region "${AWS_REGION}" \
            --filters "Name=status,Values=available" \
            --query "Volumes[].VolumeId" \
            --output text)"
          if [ -n "${available_volumes}" ] && [ "${available_volumes}" != "None" ]; then
            echo "Unattached EBS volumes found (status=available): ${available_volumes}" >&2
            exit 1
          fi

          unassociated_eips="$(aws ec2 describe-addresses \
            --region "${AWS_REGION}" \
            --query "Addresses[?AssociationId==null].AllocationId" \
            --output text)"
          if [ -n "${unassociated_eips}" ] && [ "${unassociated_eips}" != "None" ]; then
            echo "Unassociated Elastic IPs found: ${unassociated_eips}" >&2
            exit 1
          fi
