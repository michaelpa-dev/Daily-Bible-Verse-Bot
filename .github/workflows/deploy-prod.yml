name: Deploy Production (EC2 via SSM)

on:
  push:
    tags:
      - "v*"
  release:
    types:
      - published
  workflow_dispatch:
    inputs:
      release_tag:
        description: Release tag to deploy (e.g., v0.2.0). Used for manual deploys/rollbacks.
        required: true
        type: string

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  gate:
    name: Gate (Release Only)
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.gate.outputs.should_deploy }}
      release_tag: ${{ steps.gate.outputs.release_tag }}
    steps:
      - name: Resolve tag + verify published release exists
        id: gate
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN || github.token }}
        run: |
          set -euo pipefail

          should_deploy="false"
          release_tag=""

          if [ "${GITHUB_EVENT_NAME}" = "release" ]; then
            release_tag="${{ github.event.release.tag_name }}"
            is_draft="${{ github.event.release.draft }}"
            is_prerelease="${{ github.event.release.prerelease }}"

            if [ "${is_draft}" = "false" ] && [ "${is_prerelease}" = "false" ]; then
              should_deploy="true"
            else
              echo "Release ${release_tag} is draft/prerelease; production deploy is blocked."
            fi
          elif [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            release_tag="${{ github.event.inputs.release_tag }}"
          else
            # push tag event
            release_tag="${GITHUB_REF_NAME}"
          fi

          if [ -z "${release_tag}" ]; then
            echo "release_tag is empty; refusing to deploy." >&2
            echo "should_deploy=false" >> "$GITHUB_OUTPUT"
            echo "release_tag=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "${should_deploy}" != "true" ]; then
            # For tag pushes / manual deploys, only deploy if the tag corresponds to a *published* GitHub Release.
            release_json="$(gh api "repos/${GITHUB_REPOSITORY}/releases/tags/${release_tag}" -H "Accept: application/vnd.github+json" 2>/dev/null || true)"
            if [ -z "${release_json}" ]; then
              echo "No GitHub Release found for tag ${release_tag}. (This is expected if the tag was just created and the release is still building.)"
              should_deploy="false"
            else
              draft="$(printf '%s' "${release_json}" | jq -r '.draft // false')"
              prerelease="$(printf '%s' "${release_json}" | jq -r '.prerelease // false')"

              if [ "${draft}" = "false" ] && [ "${prerelease}" = "false" ]; then
                should_deploy="true"
              else
                echo "Release for ${release_tag} is draft/prerelease; production deploy is blocked."
                should_deploy="false"
              fi
            fi
          fi

          echo "should_deploy=${should_deploy}" >> "$GITHUB_OUTPUT"
          echo "release_tag=${release_tag}" >> "$GITHUB_OUTPUT"

  deploy:
    name: Deploy Production
    runs-on: ubuntu-latest
    needs: [gate]
    if: needs.gate.outputs.should_deploy == 'true'
    environment: production
    env:
      AWS_REGION: us-east-1
      AWS_ROLE_ARN: arn:aws:iam::446363550367:role/DailyBibleVerseBotGitHubActionsRole
      APP_TAG_VALUE: DailyBibleVerseBot
      BOT_TOKEN_PARAMETER_NAME: /daily-bible-verse-bot/production/BOT_TOKEN
    steps:
      - name: Configure AWS credentials (GitHub OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve production instance id (by tags)
        id: resolve
        shell: bash
        run: |
          set -euo pipefail

          instance_ids="$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --filters \
              "Name=tag:App,Values=${APP_TAG_VALUE}" \
              "Name=tag:Environment,Values=production" \
              "Name=instance-state-name,Values=pending,running,stopping,stopped" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text)"

          if [ -z "${instance_ids}" ]; then
            echo "No production instances found for App=${APP_TAG_VALUE}, Environment=production"
            exit 1
          fi

          if [ "$(echo "${instance_ids}" | wc -w | tr -d ' ')" != "1" ]; then
            echo "Expected exactly 1 production instance, found: ${instance_ids}"
            exit 1
          fi

          instance_id="${instance_ids}"
          echo "instance_id=${instance_id}" >> "$GITHUB_OUTPUT"

      - name: Ensure production instance is running
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.resolve.outputs.instance_id }}
        run: |
          set -euo pipefail

          state="$(aws ec2 describe-instances \
            --region "${AWS_REGION}" \
            --instance-ids "${INSTANCE_ID}" \
            --query "Reservations[0].Instances[0].State.Name" \
            --output text)"

          echo "Production instance state: ${state}"

          if [ "${state}" = "stopping" ]; then
            aws ec2 wait instance-stopped --region "${AWS_REGION}" --instance-ids "${INSTANCE_ID}"
            state="stopped"
          fi

          if [ "${state}" = "stopped" ]; then
            aws ec2 start-instances --region "${AWS_REGION}" --instance-ids "${INSTANCE_ID}" >/dev/null
          fi

          aws ec2 wait instance-running --region "${AWS_REGION}" --instance-ids "${INSTANCE_ID}"
          aws ec2 wait instance-status-ok --region "${AWS_REGION}" --instance-ids "${INSTANCE_ID}"

      - name: Sync BOT_TOKEN to SSM Parameter Store (SecureString)
        shell: bash
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        run: |
          set -euo pipefail
          echo "::add-mask::${BOT_TOKEN}"

          aws ssm put-parameter \
            --region "${AWS_REGION}" \
            --name "${BOT_TOKEN_PARAMETER_NAME}" \
            --type "SecureString" \
            --overwrite \
            --value "${BOT_TOKEN}" >/dev/null

      - name: Resolve GitHub release download URL (private-safe)
        id: artifact
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GH_RELEASE_TOKEN || github.token }}
          GITHUB_REPO: ${{ github.repository }}
          RELEASE_TAG: ${{ needs.gate.outputs.release_tag }}
        run: |
          set -euo pipefail
          echo "::add-mask::${GITHUB_TOKEN}"

          api="https://api.github.com"
          asset_name="daily-bible-verse-bot-${RELEASE_TAG}.tar.gz"

          release_json="$(curl -fsSL \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "${api}/repos/${GITHUB_REPO}/releases/tags/${RELEASE_TAG}")" || {
              echo "Failed to fetch release metadata for tag ${RELEASE_TAG}."
              echo "If this repo is private and the default GITHUB_TOKEN cannot read releases, set env secret GH_RELEASE_TOKEN (classic PAT with repo scope) in the 'production' environment."
              exit 1
            }

          asset_id="$(printf '%s' "${release_json}" | jq -r --arg name "${asset_name}" '.assets[] | select(.name==$name) | .id' | head -n 1 || true)"

          download_kind="release_asset"
          if [ -z "${asset_id}" ] || [ "${asset_id}" = "null" ]; then
            echo "Release asset ${asset_name} not found for ${RELEASE_TAG}; falling back to repo tarball."
            download_kind="source_archive"
            asset_name="source.tar.gz"

            headers="$(curl -sS -D - -o /dev/null \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              "${api}/repos/${GITHUB_REPO}/tarball/${RELEASE_TAG}")"
          else
            headers="$(curl -sS -D - -o /dev/null \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/octet-stream" \
              "${api}/repos/${GITHUB_REPO}/releases/assets/${asset_id}")"
          fi

          download_url="$(printf '%s' "${headers}" | awk -F': ' 'tolower($1)=="location" {print $2}' | tail -n 1 | tr -d '\r')"
          if [ -z "${download_url}" ]; then
            echo "Failed to resolve a signed download URL from GitHub API." >&2
            echo "If using GH_RELEASE_TOKEN, ensure it has access to this repo's releases." >&2
            exit 1
          fi

          echo "::add-mask::${download_url}"
          echo "asset_name=${asset_name}" >> "$GITHUB_OUTPUT"
          echo "download_url=${download_url}" >> "$GITHUB_OUTPUT"
          echo "download_kind=${download_kind}" >> "$GITHUB_OUTPUT"

      - name: Deploy production via SSM RunCommand (GitHub Release artifact)
        id: ssm
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.resolve.outputs.instance_id }}
          GITHUB_REPO: ${{ github.repository }}
          RELEASE_TAG: ${{ needs.gate.outputs.release_tag }}
          GIT_SHA: ${{ github.sha }}
          ASSET_NAME: ${{ steps.artifact.outputs.asset_name }}
          ARTIFACT_URL: ${{ steps.artifact.outputs.download_url }}
          DOWNLOAD_KIND: ${{ steps.artifact.outputs.download_kind }}
        run: |
          set -euo pipefail

          if [ -z "${RELEASE_TAG}" ]; then
            echo "RELEASE_TAG is empty; refusing to deploy." >&2
            exit 1
          fi

          deploy_script="$(cat <<SCRIPT
          set -euo pipefail

          DEPLOY_ROOT="/opt/daily-bible-verse-bot"
          ENVIRONMENT="production"
          GITHUB_REPO="${GITHUB_REPO}"
          RELEASE_TAG="${RELEASE_TAG}"
          GIT_SHA="${GIT_SHA}"
            TOKEN_PARAM="${BOT_TOKEN_PARAMETER_NAME}"

            ASSET_NAME="${ASSET_NAME}"
            ARTIFACT_URL="${ARTIFACT_URL}"
            DOWNLOAD_KIND="${DOWNLOAD_KIND}"

            WORK_DIR="/tmp/dbv-release"
            rm -rf "\${WORK_DIR}"
            mkdir -p "\${WORK_DIR}"
            cd "\${WORK_DIR}"

            echo "Downloading deploy artifact (\${DOWNLOAD_KIND}): \${ASSET_NAME}"
            curl -fL "\${ARTIFACT_URL}" -o "\${ASSET_NAME}"
            tar -xzf "\${ASSET_NAME}" -C "\${WORK_DIR}"

            DEPLOY_SCRIPT_PATH="\${WORK_DIR}/scripts/deploy/ssm-deploy.sh"
            if [ -f "\${DEPLOY_SCRIPT_PATH}" ]; then
              true
            else
              src_dir="$(ls -d "\${WORK_DIR}"/*/ | head -n 1 || true)"
              if [ -z "\${src_dir}" ]; then
                echo "Unable to locate extracted source directory." >&2
                exit 1
              fi
              DEPLOY_SCRIPT_PATH="\${src_dir}scripts/deploy/ssm-deploy.sh"
            fi

            bash "\${DEPLOY_SCRIPT_PATH}" \
              --deploy-root "\${DEPLOY_ROOT}" \
              --environment "\${ENVIRONMENT}" \
              --github-repo "\${GITHUB_REPO}" \
              --release-tag "\${RELEASE_TAG}" \
              --git-sha "\${GIT_SHA}" \
              --token-parameter "\${TOKEN_PARAM}"
          SCRIPT
          )"

          script_b64="$(printf '%s' "${deploy_script}" | base64 -w0)"

          jq -n \
            --arg instanceId "${INSTANCE_ID}" \
            --arg comment "DailyBibleVerseBot production deploy ${RELEASE_TAG}" \
            --arg scriptB64 "${script_b64}" \
            '{
              DocumentName: "AWS-RunShellScript",
              InstanceIds: [$instanceId],
              Comment: $comment,
              Parameters: {
                commands: [
                  "set -euo pipefail",
                  "printf '\''%s'\'' \"" + $scriptB64 + "\" | base64 -d > /tmp/dbv_deploy.sh",
                  "chmod +x /tmp/dbv_deploy.sh",
                  "/tmp/dbv_deploy.sh"
                ]
              }
            }' > ssm-input.json

          command_id="$(aws ssm send-command \
            --region "${AWS_REGION}" \
            --cli-input-json file://ssm-input.json \
            --query "Command.CommandId" \
            --output text)"

          echo "command_id=${command_id}" >> "$GITHUB_OUTPUT"

      - name: Wait for SSM command + surface output
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.resolve.outputs.instance_id }}
          COMMAND_ID: ${{ steps.ssm.outputs.command_id }}
        run: |
          set -euo pipefail

          set +e
          aws ssm wait command-executed --region "${AWS_REGION}" --command-id "${COMMAND_ID}" --instance-id "${INSTANCE_ID}"
          wait_exit=$?
          set -e

          status="$(aws ssm get-command-invocation \
            --region "${AWS_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "Status" \
            --output text)"

          stdout="$(aws ssm get-command-invocation \
            --region "${AWS_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "StandardOutputContent" \
            --output text)"

          stderr="$(aws ssm get-command-invocation \
            --region "${AWS_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "StandardErrorContent" \
            --output text)"

          echo "SSM status: ${status}"
          echo "${stdout}"
          if [ -n "${stderr}" ] && [ "${stderr}" != "None" ]; then
            echo "${stderr}" >&2
          fi

          if [ "${status}" != "Success" ] || [ "${wait_exit}" -ne 0 ]; then
            exit 1
          fi

      - name: Cost leak guard (unattached volumes, unassociated EIPs)
        shell: bash
        run: |
          set -euo pipefail

          available_volumes="$(aws ec2 describe-volumes \
            --region "${AWS_REGION}" \
            --filters "Name=status,Values=available" \
            --query "Volumes[].VolumeId" \
            --output text)"
          if [ -n "${available_volumes}" ] && [ "${available_volumes}" != "None" ]; then
            echo "Unattached EBS volumes found (status=available): ${available_volumes}" >&2
            exit 1
          fi

          unassociated_eips="$(aws ec2 describe-addresses \
            --region "${AWS_REGION}" \
            --query "Addresses[?AssociationId==null].AllocationId" \
            --output text)"
          if [ -n "${unassociated_eips}" ] && [ "${unassociated_eips}" != "None" ]; then
            echo "Unassociated Elastic IPs found: ${unassociated_eips}" >&2
            exit 1
          fi
